package org.idris.rts;

import java.lang.Thread;
import java.util.Map;
import java.util.HashMap;
import java.io.Closeable;
import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.nio.file.Files;
import java.nio.file.OpenOption;
import java.nio.file.StandardOpenOption;
import java.nio.channels.SeekableByteChannel;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Semaphore;

@SuppressWarnings("unchecked")
public class ForeignPrimitives {
    private static String args[];
    private static final Semaphore messageMutex = new Semaphore(1);
    private static final Map<Thread, BlockingQueue<Object>> messages = new HashMap<Thread, BlockingQueue<Object>>();
    

    public static synchronized void idris_sendMessage(Object from, Object dest, Object message) throws InterruptedException {
	messageMutex.acquire();
	BlockingQueue<Object> messagesForTarget = messages.get((Thread)dest);
	if (messagesForTarget == null) {
	    messagesForTarget = new LinkedBlockingQueue<Object>();
	    messages.put((Thread)dest, messagesForTarget);
	}
	messagesForTarget.put(message);
        messageMutex.release();
    }

    public static synchronized int idris_checkMessage(Object dest) throws InterruptedException {
	messageMutex.acquire();
	BlockingQueue<Object> messagesForTarget = messages.get((Thread)dest);
	messageMutex.release();
	return (messagesForTarget == null ? 0 : messagesForTarget.size());
    }

    public static synchronized Object idris_recvMessage(Object dest) throws InterruptedException {
	messageMutex.acquire();
	BlockingQueue<Object> messagesForTarget = messages.get((Thread)dest);
	if (messagesForTarget == null) {
	    messagesForTarget = new LinkedBlockingQueue();
	    messages.put((Thread)dest, messagesForTarget);
	}
	messageMutex.release();
	return messagesForTarget.take();
    }

    public static void putStr(String str) {
	System.out.println(str);
    }

    public static void putchar(char c) {
	System.out.println(c);
    }

    public static int getchar() {
	try {
	    return (char)System.in.read();
	} catch (IOException ex) {
	    return -1;
	}
    }

    public static SeekableByteChannel fileOpen(String name, String privs) {
	try {
	    OpenOption [] options;
	    switch (privs) {
		case "r" : 
		    options = new StandardOpenOption [] 
			{ StandardOpenOption.READ }; 
		    break;
		case "r+" : 
		    options = new StandardOpenOption []
			{ StandardOpenOption.READ, 
			  StandardOpenOption.WRITE }; 
		    break;
		case "w" : 
		    options = new StandardOpenOption []
			{ StandardOpenOption.WRITE, 
			  StandardOpenOption.CREATE }; 
		    break;
		case "w+" : 
		    options = new StandardOpenOption []
			{ StandardOpenOption.READ, 
			  StandardOpenOption.WRITE, 
			  StandardOpenOption.CREATE }; 
		    break;
		case "a" : 
		    options = new StandardOpenOption []
			{ StandardOpenOption.WRITE, 
			  StandardOpenOption.CREATE, 
			  StandardOpenOption.APPEND }; 
		    break;
		case "a+" : 
		    options = new StandardOpenOption []
			{ StandardOpenOption.READ, 
			  StandardOpenOption.WRITE, 
			  StandardOpenOption.CREATE, 
			  StandardOpenOption.APPEND }; 
		    break;
	        default : 
		    options = new StandardOpenOption [] {};
		    break;
	    }
	    return Files.newByteChannel(new File(name).toPath(), options);
	} catch (IOException ex) {
	    return null;
	}
    }

    public static void fileClose(Object file) throws IOException {
	((Closeable)file).close();
    }

    public static void fputStr(Object file, String string) throws IOException {
	if (file instanceof PrintStream) {
	    ((PrintStream)file).print(string);
	} else if (file instanceof SeekableByteChannel) {
	    ((SeekableByteChannel)file).write(ByteBuffer.wrap(string.getBytes()));
	}
    }

    public static int fileEOF(Object file) {
	try {
	    if (file instanceof SeekableByteChannel) {
		SeekableByteChanel bc = (SeekableByteChannel)file;
		return bc.position() == bc.size();
	    }
	} catch (IOException | CloseableException ex) {
	    return -1;
	}
	return 0;
    }
}
